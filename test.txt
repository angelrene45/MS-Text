import psutil
import time
import os
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
from opentelemetry.sdk.resources import Resource

# Configure OpenTelemetry with best practices
resource = Resource.create({
    "service.name": "resource-monitor",
    "host.name": os.uname().nodename
})

provider = TracerProvider(resource=resource)
exporter = OTLPSpanExporter(endpoint="your-otlp-endpoint")
span_processor = BatchSpanProcessor(exporter)
provider.add_span_processor(span_processor)
trace.set_tracer_provider(provider)
tracer = trace.get_tracer(__name__)

# Thresholds for resource usage
CPU_THRESHOLD = 80  # CPU usage percentage
MEMORY_THRESHOLD = 80  # Memory usage percentage
BYTES_SENT_THRESHOLD = 1000000  # Network bytes sent per second (1 MB)
BYTES_RECV_THRESHOLD = 1000000  # Network bytes received per second (1 MB)

def log_top_processes(span):
    """Logs the top processes consuming the most resources."""
    top_processes = sorted(psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent']),
                           key=lambda p: p.info['cpu_percent'] + p.info['memory_percent'], reverse=True)[:10]
    
    for proc in top_processes:
        span.add_event("top_process", {
            "process.pid": proc.info['pid'],
            "process.name": proc.info['name'],
            "process.cpu_percent": proc.info['cpu_percent'],
            "process.memory_percent": proc.info['memory_percent'],
            "process.status": proc.status(),
            "process.create_time": proc.create_time(),
            "process.threads": proc.num_threads()
        })

def monitor_resources():
    while True:
        with tracer.start_as_current_span("resource_monitoring") as span:
            # CPU usage monitoring
            cpu_usage = psutil.cpu_percent(interval=1)
            span.set_attribute("cpu.usage_percent", cpu_usage)

            # Memory usage monitoring
            memory_info = psutil.virtual_memory()
            span.set_attribute("memory.total", memory_info.total)
            span.set_attribute("memory.available", memory_info.available)
            span.set_attribute("memory.used", memory_info.used)
            span.set_attribute("memory.usage_percent", memory_info.percent)

            # Network usage monitoring
            net_io = psutil.net_io_counters()
            span.set_attribute("network.bytes_sent", net_io.bytes_sent)
            span.set_attribute("network.bytes_recv", net_io.bytes_recv)

            # Check for high resource usage
            if cpu_usage > CPU_THRESHOLD or memory_info.percent > MEMORY_THRESHOLD:
                span.add_event("high_resource_usage_alert", {
                    "cpu.usage_percent": cpu_usage,
                    "memory.usage_percent": memory_info.percent
                })
                log_top_processes(span)

            # Check for high network usage
            if net_io.bytes_sent > BYTES_SENT_THRESHOLD or net_io.bytes_recv > BYTES_RECV_THRESHOLD:
                span.add_event("high_network_usage_alert", {
                    "network.bytes_sent": net_io.bytes_sent,
                    "network.bytes_recv": net_io.bytes_recv
                })
                log_top_processes(span)

            # Local output for monitoring
            print(f"CPU Usage: {cpu_usage}%")
            print(f"Memory Usage: {memory_info.percent}%")
            print(f"Network - Bytes Sent: {net_io.bytes_sent}, Bytes Received: {net_io.bytes_recv}")

            # Sleep for a defined interval
            time.sleep(10)

if __name__ == "__main__":
    try:
        monitor_resources()
    except KeyboardInterrupt:
        print("Resource monitoring stopped.")
