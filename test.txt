from prometheus_client import start_http_server, Gauge
import psutil
import time
import argparse

from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.trace import set_tracer_provider

# Parse command-line arguments
parser = argparse.ArgumentParser(description="Monitor CPU and memory usage with Prometheus and send traces if thresholds are exceeded.")
parser.add_argument("--cpu-threshold", type=float, default=50.0, help="CPU usage threshold percentage (default: 50%)")
parser.add_argument("--memory-threshold", type=float, default=50.0, help="Memory usage threshold percentage (default: 50%)")
args = parser.parse_args()

CPU_THRESHOLD = args.cpu_threshold
MEMORY_THRESHOLD = args.memory_threshold

# Prometheus metrics
cpu_usage_metric = Gauge("server_cpu_usage", "Current CPU usage percentage")
memory_usage_metric = Gauge("server_memory_usage", "Current memory usage percentage")

# OpenTelemetry tracing setup
trace_provider = TracerProvider()
trace_exporter = OTLPSpanExporter(endpoint="http://localhost:4317", insecure=True)
trace_provider.add_span_processor(BatchSpanProcessor(trace_exporter))
set_tracer_provider(trace_provider)
tracer = trace_provider.get_tracer("server_tracer")

def capture_top_processes():
    """ Captures and traces the top 50 processes when CPU or Memory exceeds the threshold. """
    cpu_usage = psutil.cpu_percent(interval=1)
    memory_usage = psutil.virtual_memory().percent

    # Update Prometheus metrics
    cpu_usage_metric.set(cpu_usage)
    memory_usage_metric.set(memory_usage)

    print(f"Metrics updated - CPU: {cpu_usage}% | RAM: {memory_usage}%")

    if cpu_usage > CPU_THRESHOLD or memory_usage > MEMORY_THRESHOLD:
        # Create a trace for high CPU/memory usage
        with tracer.start_as_current_span("High CPU/Memory Usage") as span:
            span.set_attribute("cpu.usage", cpu_usage)
            span.set_attribute("memory.usage", memory_usage)

            # Get the top 50 processes sorted by CPU usage
            processes = sorted(psutil.process_iter(['pid', 'name', 'cpu_percent', 'memory_percent', 'username']),
                               key=lambda p: p.info['cpu_percent'], reverse=True)[:50]
            
            process_info = []
            for proc in processes:
                try:
                    proc_info = {
                        "pid": proc.info['pid'],
                        "name": proc.info['name'],
                        "cpu": proc.info['cpu_percent'],
                        "memory": proc.info['memory_percent'],
                        "user": proc.info['username']
                    }
                    process_info.append(proc_info)
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    # Skip processes that cannot be accessed
                    continue  
            
            # Attach process info to the trace
            span.set_attribute("top_50_processes", str(process_info))
            print(f"ðŸ”´ ALERT: CPU={cpu_usage}% RAM={memory_usage}%, sending trace with top 50 processes")

if __name__ == "__main__":
    print(f"ðŸš€ Starting Prometheus Metrics Server on port 8000 (Thresholds: CPU>{CPU_THRESHOLD}%, RAM>{MEMORY_THRESHOLD}%)")
    start_http_server(8000)  # Expose metrics at http://localhost:8000
    
    # Continuous monitoring loop
    while True:
        capture_top_processes()
        time.sleep(10)  # Update every 10 seconds
